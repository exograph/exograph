context AuthContext {
  @jwt("sub") id: Int 
  @jwt("roles") roles: Array<String> 
}

@postgres
service DocumentService {
  @access(query="ADMIN" in AuthContext.roles || self.public, mutation="ADMIN" in AuthContext.roles)
  type Doc {
    @pk id: Int = autoincrement()
    content: String
    public: Boolean
  }
  
  // Only admins can do anything with this model
  @access("ADMIN" in AuthContext.roles) 
  type AdminDoc {
    @pk id: Int = autoincrement()
    content: String
  }
  
  // An example of nested access control (users can see there own membership)
  @access(query="ADMIN" in AuthContext.roles || self.user.id == AuthContext.id, mutation="ADMIN" in AuthContext.roles)
  type Membership {
    @pk id: Int = autoincrement()
    kind: String
    user: User
  }
  
  @access("ADMIN" in AuthContext.roles)
  type User {
    @pk id: Int = autoincrement()
    name: String
    membership: Membership?
  }
}