model Concert {
  id: Int @pk @autoincrement
  title: String
  venue: Venue @column("venueid")
  published: Boolean
  price: Decimal @precision(20) @scale(2)
}

model Venue {
  id: Int @pk @autoincrement
  name: String
  concerts: Set<Concert> @column("venueid")
  published: Boolean
  latitude: Float @size(4)
}

model Log {
  id: Int @pk @autoincrement
  message: String
}

@external("log.js")
service Logging {
  @before("mutation *Concert*")
  interceptor enterConcertMutation(operation: Operation, claytip: Claytip)

  @before("mutation *Venue*")
  interceptor enterVenueMutation(operation: Operation, claytip: Claytip)

  @after("mutation *Concert*")
  interceptor exitConcertMutation(operation: Operation, claytip: Claytip)

  @after("mutation *Venue*")
  interceptor exitVenueMutation(operation: Operation, claytip: Claytip)

  // Put an `after` interceptor ahead of the `before` interceptor to test that the `before` interceptor
  // still applies before the `after` interceptor.
  @after("query *")
  interceptor exitQuery(operation: Operation, claytip: Claytip)

  @before("query *")
  interceptor enterQuery(operation: Operation, claytip: Claytip)

  // TODO: Investigate why this doesn't work (when we have this along with the other around, we seem to block forever)
  // @around("query *")
  // interceptor rateLimitingQuery(operation: Operation, claytip: Claytip)

  @around("query *")
  interceptor timingQuery(operation: Operation, claytip: Claytip)

  // TODO: Make this work (and drop the requirement that the interceptor expression is a string)
  // @before("mutation *" && !"mutation *Log")
  // interceptor enterMutation(operation: Operation, claytip: Claytip)
}